# MCP問題解決型スライド骨組み（アーキテクチャ図中心）

## スライド構成

### 1. タイトルスライド
**Model Context Protocol (MCP)**
- AIとツールの統合を変革する標準プロトコル
- 2024年11月 Anthropic発表

### 2. 現在のAI活用における根本的な課題

**問題：AIは賢いが、実行能力がない**

```
現状のアーキテクチャ：
┌─────────┐     テキスト     ┌─────────┐
│   AI    │ ←────────────→ │ ユーザー │
└─────────┘                └─────────┘
     ↓                          ↓
  アドバイス                 手動実行
   のみ                    （非効率）
```

**具体例：**
- 「ファイルを整理して」→ 整理方法の説明だけ
- 「データを分析して」→ 分析手法の提案だけ
- 「コードをデプロイして」→ 手順の説明だけ

### 3. Function Calling時代の部分的解決と新たな問題

**解決：AIがツールを呼び出せるように**

```
各社独自の実装：
┌─────────┐     
│OpenAI AI│ ←──→ OpenAI専用ツール
└─────────┘     
┌─────────┐     
│Claude AI│ ←──→ Claude専用ツール  
└─────────┘     
```

**新たな問題：**
- ベンダーロックイン
- 重複開発の非効率性
- ツールの相互運用性なし

### 4. MCPによる根本的解決

**解決：統一プロトコルによる標準化**

```
MCPアーキテクチャ：
┌─────────┐     ┌─────────┐     ┌──────────┐
│   AI    │────→│   MCP   │────→│ ツール群  │
│(どのAIも)│     │プロトコル│     │(共通規格) │
└─────────┘     └─────────┘     └──────────┘
                  JSON-RPC 2.0
```

**メリット：**
- 一度作れば、どのAIでも使える
- オープン標準（ベンダー非依存）
- エコシステムの急速な成長

### 5. MCPの2つのトランスポート層

**問題：ツールの実行場所によって通信方法が異なる**

```
トランスポート選択：
┌─────────────────────────────────────┐
│            MCPクライアント           │
└─────────┬───────────────┬───────────┘
          │               │
    stdio │               │ Streamable HTTP
          ↓               ↓
┌─────────────┐   ┌─────────────┐
│ローカルツール│   │リモートツール│
│・ファイル操作│   │・Web API     │
│・システム実行│   │・クラウド連携│
└─────────────┘   └─────────────┘
```

**解決：用途に応じた最適な通信方式**

### 6. 実装例：ローカルツール連携

**問題：ローカルファイルやシステムとの連携**

```
stdioトランスポート：
┌─────────┐  プロセス起動  ┌────────────┐
│Claude   │──────────────→│ MCPサーバー │
│Code     │←──────────────│(ファイル系) │
└─────────┘  標準入出力    └────────────┘
                              │
                              ↓
                         ローカルファイル
```

**活用例：**
- ファイルの自動整理
- コードの自動修正とコミット
- スクリーンショット撮影

### 7. 実装例：Web API連携

**問題：外部サービスとの連携**

```
Streamable HTTPトランスポート：
┌─────────┐   HTTP POST    ┌────────────┐
│   AI    │───────────────→│MCPサーバー │
│         │←───────────────│(API Gateway)│
└─────────┘   SSE Stream    └────────────┘
                                 │
                    ┌────────────┼────────────┐
                    ↓            ↓            ↓
                 Slack API   GitHub API   他のAPI
```

**活用例：**
- Slackへの自動投稿
- GitHubのPR作成
- データベースクエリ実行

### 8. HTTP+SSEからStreamable HTTPへの進化

**問題：初期仕様の複雑性**

```
旧仕様（2024年11月）：
HTTP ────→ リクエスト専用
SSE  ←──── レスポンス専用
（2つの別々のトランスポート）

新仕様（2025年現在）：
Streamable HTTP ←→ 統合された双方向通信
```

**解決：シンプルで効率的な単一プロトコル**

### 9. エコシステムの急速な成長

**問題：ツールの可用性**

```
エコシステムの拡大：
2024年11月：数個のツール
     ↓
2025年1月：250+ MCPサーバー

カテゴリ別：
├── 開発ツール（Git, Docker, IDE連携）
├── 生産性（Notion, Slack, Calendar）
├── データ（Database, Analytics, BI）
└── インフラ（AWS, GCP, Azure）
```

**解決：あらゆる用途に対応可能**

### 10. iPaaS×MCPによる未来

**問題：従来の統合プラットフォームの限界**

```
現在のiPaaS：
ユーザー → UI設定 → 実行

MCP統合後：
ユーザー → 自然言語 → AI → 自動統合
         「AをBに連携して」
```

**予測される変化：**
- 2025-2027: 主要iPaaS企業のMCP対応
- 統合作業の民主化
- エンタープライズ採用の加速

### 11. 導入の判断基準

**どのトランスポートを選ぶか**

```
判断フロー：
ツールの場所は？
├── ローカル → stdio
│   └── 高速・セキュア・オフライン可
└── リモート → Streamable HTTP
    └── スケーラブル・共有可能
```

**実装の優先順位：**
1. まずローカルツールから始める
2. 徐々にWeb API連携を追加
3. 最終的に完全自動化へ

### 12. まとめ：MCPがもたらす変革

**Before MCP：**
- AI = 高性能なアドバイザー
- 実行は人間
- ツールはベンダー依存

**After MCP：**
- AI = 実行力を持つパートナー
- 自動実行
- オープンエコシステム

**Call to Action：**
- Claude Codeで今すぐ試せる
- 250+のMCPサーバーが利用可能
- まずは簡単なファイル操作から